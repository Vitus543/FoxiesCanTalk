{
	"compilerOptions": {
		"esModuleInterop": true,
		"jsx": "react",
		"module": "esnext",
		"moduleResolution": "node",
		"lib": ["dom", "esnext"],
		"strict": true,
		"sourceMap": true,
		"target": "esnext"
	},
	"exclude": ["node_modules"]
}
// 	"target": "es6",
// 	"lib": ["dom", "dom.iterable", "esnext"],
// 	"allowJs": true,
// 	"skipLibCheck": true,
// 	"esModuleInterop": true,
// 	"allowSyntheticDefaultImports": true,
// 	"strict": true,
// 	"forceConsistentCasingInFileNames": true,
// 	"module": "esnext",
// 	"moduleResolution": "node",
// 	"resolveJsonModule": true,
// 	"isolatedModules": true,
// 	"noEmit": true,
// 	"jsx": "react-jsx",
// 	"noImplicitAny": true,
// 	"noFallthroughCasesInSwitch": true
// },
// "exclude": ["node_modules"],
// "include": ["src"]
//}
/*
compilerOptions
esModuleInterop â€” the flag fixes default and namespace imports from CommonJS to TS. That's just needed ðŸ™‚
jsx â€” tells TS how to treat JSX files
module â€” the option tells TS how to transpile ES6 imports and exports; esnext leaves them unchanged. I recommend setting always esnext to leave this job to webpack.
moduleResolution â€” historically TS used to resolve modules in other way than Node.js, so this must be set to node
lib â€” this option tells TS which libraries will exist in your target environment, so TS implicitly imports their types. TS won't be able to check if these libs really exist in runtime, so that's your promise. More on this later.
strict â€” enables all TS type checks
sourceMap â€” enables TS emitting source maps. We will configure webpack to ignore source maps in production builds.
target â€” configures target ES version which depends on your users; more on this later.
exclude â€” this option excludes libs from typechecking and transpiling; however your code is still checked against typedefs provided by libs.
*/
